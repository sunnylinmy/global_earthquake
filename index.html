<meta charset="utf-8">
<head>
<link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet" type="text/css">
<title>Earthquakes with 1,000 or More Deaths 1900-2014</title>
<style type="text/css">
  .text {
    font-family: "Roboto", sans-serif;
    fill: #ddd;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    font-size: 1px;
  }

  .yearText {
      font-size: 60px ;
  }

  .monthText {
      font-size: 30px ;
  }

  .button {
    fill: red;
  }

path.line {
  fill: none;
  stroke: blue;
  stroke-width: 1.5px;
}

path.area {
  fill: #e7e7e7;
}

div.tooltip {
    background: white;
    text-align: left;
    padding-left: 5px;
    width: auto;
    max-width: 700px;
    height: auto;
    font-size: 14px;
    border:solid gray;
    position: absolute;
    border-radius: 8px;
    border: 1px;
    pointer-events: none;
}

body{
  line-height: 1.5;
  font-family: "Roboto", sans-serif;
}

h1{
  text-align: center;
}

svg{
  margin-left: auto;
  margin-right: auto;
  display: block;
}

.subunit-label{
  fill: #777;
  fill-opacity: .5;
  font-size: 4px;
  text-anchor: middle;
}
#deathbutton{
  pointer-events: all;
  fill: red;
  fill-opacity: 0.5;
}

#magnitudebutton{
  fill: #cc8400;
  pointer-events: all;
  fill-opacity: 0.5;
}

#instruction{
  width: 1300px;
  margin: auto;
  display: block;
}

.pace {
  -webkit-pointer-events: none;
  pointer-events: none;

  -webkit-user-select: none;
  -moz-user-select: none;
  user-select: none;

  z-index: 2000;
  position: fixed;
  margin: auto;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  height: 5px;
  width: 200px;
  background: #fff;
  border: 1px solid #b62222;

  overflow: hidden;
}

.pace .pace-progress {
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  -ms-box-sizing: border-box;
  -o-box-sizing: border-box;
  box-sizing: border-box;

  -webkit-transform: translate3d(0, 0, 0);
  -moz-transform: translate3d(0, 0, 0);
  -ms-transform: translate3d(0, 0, 0);
  -o-transform: translate3d(0, 0, 0);
  transform: translate3d(0, 0, 0);

  max-width: 200px;
  position: fixed;
  z-index: 2000;
  display: block;
  position: absolute;
  top: 0;
  right: 100%;
  height: 100%;
  width: 100%;
  background: #b62222;
}

.pace.pace-inactive {
  display: none;
}


</style>
</head>
<body>
<h1>Earthquakes with 1,000 or More Deaths 1900-2014</h1>
<div class="container"></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/topojson/1.6.19/topojson.min.js"></script>
<script src="lib/d3.geo.projection.v0.min.js" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/pace.min.js"></script>
<script src="lib/jquery-1.12.0.min.js"></script>
<svg></svg>
<p id="instruction">Instruction: Double click countries on the map to zoom in. Click "Zoom Out" to zoom out. Click "Start" and "End" to see the change in time. Use "Deaths" and "Magnitude" to toggle the different measures. Hover on circle to see the description of every earthquake.<br>
Data Source: <a href="http://earthquake.usgs.gov/earthquakes/world/world_deaths.php">USGS - Earthquake Hazards Program</a></p>
<script>
// To get a d3 data visualization job, you have to show them you really know something about d3.
var width = 1500,
    height = 700;

var scaleFactor = 1,
    centered,
    g,
    zoombutton;

var svg = d3.select("svg")
    .attr("width", width)
    .attr("height", height)
    .attr("visibility","hidden")
    .attr("id","mainsvg");

d3.select("#instruction").attr("visibility","hidden");

var div = d3.select("body").append("div")   
  .attr("class", "tooltip")               
  .style("opacity",0);

var path, geoData, color, earthquakeData, projection;

//--------------------------------------
// Date format from CSV file: "4/5/2006"
var timeFormat = d3.time.format("%m/%d/%Y");

var startDate = new Date(1900,0),
    endDate   = new Date(2014,11) ;

var startNum = +startDate,
    endNum = +endDate ;

var dateInterp = d3.interpolateNumber(startNum, endNum) ;

var monthNames = [
        "January", "February", "March",
        "April", "May", "June", "July",
        "August", "September", "October",
        "November", "December"
    ];

var zoomX = 100,
    zoomY = 0.1*height,
    startY = zoomY +30,
    endY = startY +30,
    deathY = endY +30,
    magnitudeY = deathY+30,
    yearX = zoomX,
    yearY = 0.9*height,
    zoomWidth = 70,
    zoomHeight = 20,
    bdx = 5;



d3.json("world_all_withoutAntarctica.json",function(topo){
    d3.csv("data.csv",type,function(error,data){

//        textYear.attr('visibility','visible') ;

        geoData = topojson.feature(topo,topo.objects.countries) ;

        projection = d3.geo.eckert3();

        path = d3.geo.path().projection(projection);

      var center = d3.geo.centroid(geoData)
      var scale  = 250;
      var offset = [width/2, height/2];
      projection = d3.geo.eckert3()
        .scale(scale)
        .center(center)
        .translate(offset);

      // create the path
      path = d3.geo.path()
        .projection(projection);

      // using the path determine the bounds of the current map and use 
      // these to determine better values for the scale and translation

      var bounds  = path.bounds(geoData);
      var hscale  = scale*width  / (bounds[1][0] - bounds[0][0]);
      var vscale  = scale*height / (bounds[1][1] - bounds[0][1]);
      var scale   = (hscale < vscale) ? hscale : vscale;
      var offset  = [width - (bounds[0][0] + bounds[1][0])/2,
                        height - (bounds[0][1] + bounds[1][1])/2];

      // new projection
      projection = d3.geo.eckert3()
        .center(center)
        .scale(scale*0.95)
        .translate(offset);

      path = path.projection(projection);

      deathData = data.map(DEATH).sort(d3.ascending);
      minDeath = deathData[0];
      maxDeath = deathData[deathData.length-1];

      radiusDeath = d3.scale.linear().domain([minDeath,maxDeath]).range([3,40]);

      magnitudeData = data.map(MAGNITUDE).sort(d3.ascending);
      minMagnitude = magnitudeData[1];
      maxMagnitude = magnitudeData[magnitudeData.length-1];

      radiusMagnitude = d3.scale.linear().domain([minMagnitude,maxMagnitude]).range([2,20]);

     g = svg.append("g");

       g.append("g")
        .attr("class","region")
        .selectAll("path")
        .data(geoData.features)
        .enter()
        .append("path")
        .attr("d", path)
        .attr("fill", "transparent")
        .attr("id",function(d) {
                  return d.id;})
        .attr("stroke","black")
        .attr("stroke-width", 0.5)
        .style("opacity",1)
        .on("dblclick",clicked);

        g.selectAll(".subunit_label")
         .data(topojson.feature(topo,topo.objects.countries).features)
         .enter()
         .append("text")
         .attr("transform",function(d){
            if (d.properties.name=="France"){
                return "translate(" + (path.centroid(d)[0]+18)+","+(path.centroid(d)[1]-20) + ")";
            }else if (d.properties.name=="United States"){
                return "translate(" + (path.centroid(d)[0]+10)+","+(path.centroid(d)[1]+20) + ")";
            }else if (d.properties.name =="Canada"){
                return "translate(" + (path.centroid(d)[0]-30)+","+(path.centroid(d)[1]+10) + ")";
            }else{
                return "translate(" + (path.centroid(d)[0])+","+(path.centroid(d)[1]) + ")";
            };
          })
         .attr("dy",".35em")
         .style("opacity",function(d){
              return path.area(d.geometry)*scaleFactor >100 ? 1:0;
         })
         .text(function(d) {return d.properties.name;})
         .attr("text-anchor","middle")
         .style("font-size",function(d){

          areaData = topojson.feature(topo,topo.objects.countries).features.map(AREA).sort(d3.ascending);
          minArea = areaData[0];
          maxArea = areaData[areaData.length-1];
              if (path.area(d.geometry)>500){
                var fontsizeDeceiver = d3.scale.linear().domain([minArea,maxArea]).range([5,20]);
              return fontsizeDeceiver(path.area(d.geometry));
            }else{
              var fontsizeDeceiver = d3.scale.linear().domain([minArea,maxArea]).range([3,4]);
              return fontsizeDeceiver(path.area(d.geometry));
            }
         })
         .style("pointer-events","none");

      // Order to make sure the smallest is on the top
      function order(a,b){
        return radiusDeath(a) - radiusDeath(b);
      };

      function orderMagnitude(a,b){
        return radiusMagnitude(a) - radiusMagnitude(b);
      };

         quake = g.append("g").attr("class","deathCircle").selectAll("circle").data(data)
          .enter()
          .append("circle")
          .attr("visibility","hidden")
         .attr("cx", function(d) {
                return projection([+d.Latitude, +d.Longitude])[0];
            })
            .attr("cy", function(d) {
                return projection([+d.Latitude, +d.Longitude])[1];
            })
          .style("fill", "red")
          .style("fill-opacity", 0.5)
          .style("stroke", "red")
          .style("stroke-opacity", 0.5)
          .attr("r", function(d){ return radiusDeath(d.Death);})
          .sort(order)
          .on("mouseover",function(d){
                d3.select(this).transition().duration(300).style('opacity',1).attr("fill","#fee391");
                div.transition().duration(300).style("opacity",1);

                div.html("<p>Year: " + d.Date + "<br>"+"Death: "+ d3.round(d.Death,0)+"<br>"+"Location: " + d.Location +"<br>"+"Magnitude: "+ d.Magnitude +"<br>"+"Comments: "+ d.Comments +"</p>")
                .style("left",(d3.event.pageX)+"px")
                .style("top",(d3.event.pageY+30) +"px");
          }).on("mouseout",function(){
               d3.select(this)
                  .transition()
                  .duration(300)
                  .style("opacity",1)
                  .attr("fill","red");
              div.transition()
                  .duration(300)
                  .style("opacity", 0);
          }).on("dblclick",clicked);

          buttonset = svg.append("g").attr("class","buttonset");

          zoombutton = buttonset.append("rect")
            .attr("x",zoomX)
            .attr("y",zoomY)
            .attr("width",zoomWidth)
            .attr("height",zoomHeight)
            .attr("fill","#D3D3D3")
            .attr("stroke-width",1.5)
            .attr("rx",8)
            .on("click",clickOut)
            .style("pointer-events","pointer");

             svg.append("text")
          .attr("x",zoomX+bdx)
          .attr("y",zoomY+zoomHeight*0.7)
          .attr("fill","black")
          .attr("text-anchor","start")
          .attr("font-size","13")
          .style("pointer-events",'none')
          .style("-webkit-user-select","none")
          .text("Zoom Out");

           textYear = svg.append("text").attr("id","textYear")
            .attr("x",yearX)
            .attr("y",yearY)
            .classed("yearText text",true)
            .text(startDate.getFullYear().toString())
            .attr('visibility','hidden');

          startbutton = buttonset.append("rect")
            .attr("x",zoomX)
            .attr("y",startY)
            .attr("width",zoomWidth)
            .attr("height",zoomHeight)
            .attr("fill","#D3D3D3")
            .attr("stroke-width",1.5)
            .attr("rx",8)
            .on("click",plotQuake)
            .style("pointer-events","pointer");

          svg.append("text")
          .attr("x",zoomX+bdx+15)
          .attr("y",startY+zoomHeight*0.7)
          .attr("fill","black")
          .attr("text-anchor","start")
          .attr("font-size","13")
          .style("pointer-events",'none')
          .style("-webkit-user-select","none")
          .text("Start");

          endbutton = buttonset.append("rect")
            .attr("x",zoomX)
            .attr("y",endY)
            .attr("width",zoomWidth)
            .attr("height",zoomHeight)
            .attr("fill","#D3D3D3")
            .attr("stroke-width",1.5)
            .attr("rx",8)
            .on("click",endplotQuake)
            .style("pointer-events","pointer");

          svg.append("text")
          .attr("x",zoomX+bdx+15)
          .attr("y",endY+zoomHeight*0.7)
          .attr("fill","black")
          .attr("text-anchor","start")
          .attr("font-size","13")
          .style("pointer-events",'none')
          .style("-webkit-user-select","none")
          .text("End");

          deathbutton = buttonset.append("rect").attr("id","deathbutton")
            .attr("x",zoomX)
            .attr("y",deathY)
            .attr("width",zoomWidth)
            .attr("height",zoomHeight)
            .attr("fill","#D3D3D3")
            .attr("stroke-width",1.5)
            .attr("rx",8)
            .on("click",changetoDeath)
            .style("pointer-events","pointer");

          svg.append("text")
          .attr("x",zoomX+bdx+15)
          .attr("y",deathY+zoomHeight*0.7)
          .attr("fill","black")
          .attr("text-anchor","start")
          .attr("font-size","13")
          .style("pointer-events",'none')
          .style("-webkit-user-select","none")
          .text("Deaths");

          magnitudebutton = buttonset.append("rect").attr("id","magnitudebutton")
            .attr("x",zoomX)
            .attr("y",magnitudeY)
            .attr("width",zoomWidth)
            .attr("height",zoomHeight)
            .attr("fill","#D3D3D3")
            .attr("stroke-width",1.5)
            .attr("rx",8)
            .on("click",changetoMagnitude)
            .style("pointer-events","pointer");

          svg.append("text")
          .attr("x",zoomX+bdx)
          .attr("y",magnitudeY+zoomHeight*0.7)
          .attr("fill","black")
          .attr("text-anchor","start")
          .attr("font-size","13")
          .style("pointer-events",'none')
          .style("-webkit-user-select","none")
          .text("Magnitude");


                // Pace.stop() ;
        Pace.on("done", function() {
          svg.attr("visibility","visible") ;
          d3.select("#instruction").attr("visibility","visible");
        })
         
    });
});

function DEATH(d) {return +d.Death;};
function MAGNITUDE(d) {return +d.Magnitude;};

function AREA(d){return +path.area(d.geometry);}

// Click function for zooming in on double clicked area
function clicked(d) {
  var x, y;
  var mousePos = d3.mouse(this) ;

  if (d) {
    x = mousePos[0] ;
    y = mousePos[1] ;
    scaleFactor *= 2 ;
    scaleFactor = Math.min(scaleFactor,32) ;
  } else {
    x = width / 2;
    y = height / 2;
    scaleFactor = 1 ;
  }

  // This is for coloring the clicked states
  g.selectAll("path")
    .classed("active", centered && function(d) { return d === centered; });

  g.transition()
    .duration(750)
    .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")scale(" + scaleFactor + ")translate(" + -x + "," + -y + ")")
    .style("stroke-width", 1.25 / scaleFactor + "px");

};

// Zoom out to the original view
function clickOut() {
  var x, y;

  x = width / 2;
  y = height / 2;
  scaleFactor = 1;

  g.transition()
    .duration(750)
    .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")scale(" + scaleFactor + ")translate(" + -x + "," + -y + ")")
    .style("stroke-width", 1.5 / scaleFactor + "px");
}

function type(d) {
  d.happened = +timeFormat.parse(d.Date);
 // d.Date= parseTime(d.Date);
  d.Death = +d.Death;
  return d;
}

function plotQuake() {

   textYear.attr('visibility','visible');
        var ii = -1 ;

        quake.transition()
            .duration(20000)
            .ease("linear")
            .attrTween("visibility",function(d, i, a){
                return function(t) {
                    if (ii !== t) {
                        var cDate = new Date(dateInterp(t))
                        textYear.text(cDate.getFullYear().toString()) ;
                        ii = t ;
                    };

                    if (d.happened <= dateInterp(t)) {
                        return "visible" ;
                    } else {
                        return "hidden" ;
                    }
                }
            })
};

function endplotQuake(){
  textYear.attr('visibility','hidden');
  quake.transition().duration(300).ease("linear").attr("visibility","visible");
};

function changetoMagnitude(){

      function orderMagnitude(a,b){
        return radiusMagnitude(a) - radiusMagnitude(b);
      };

        quake.transition()
        .sort(orderMagnitude)
        .attr("r",function(d){ return radiusMagnitude(d.Magnitude);})
        .style("fill", "#cc8400")
        .style("fill-opacity", 0.5)
        .style("stroke", "#cc8400")
        .style("stroke-opacity", 0.5);

    var x = document.getElementById("textYear").textContent;
    if (x>1900 && x<=2014){
       quake
    .attrTween("visibility",function(d, i, a){
                return function(t) {
                    if (d.happened <= dateInterp(t)) {
                        return "visible" ;
                    } else {
                        return "hidden" ;
                    }
                }
            });    
    }else{
    quake
        .attr("visibility","visible");
    };

}

function changetoDeath(){

   function order(a,b){
        return radiusDeath(a) - radiusDeath(b);
      };

      quake.transition()
    .sort(order)
    .attr("r",function(d){ return radiusDeath(d.Death);})
    .style("fill", "red")
    .style("fill-opacity", 0.5)
    .style("stroke", "red")
    .style("stroke-opacity", 0.5);

   var y = document.getElementById("textYear").textContent;
    if (y>1900 && y<=2014){
    quake
    .attrTween("visibility",function(d, i, a){
                return function(t) {
                    if (d.happened <= dateInterp(t)) {
                        return "visible" ;
                    } else {
                        return "hidden" ;
                    }
                }
            });

    }else{
     quake  
    .attr("visibility","visible");
    };
   
}

</script>
</body>
