<meta charset="utf-8">
<style type="text/css">
  .text {
    font-family: "Helvetica Neue", sans-serif;
    font-weight:100 ;
    fill: #ddd;

    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
  }

  .yearText {
      font-size: 60px ;
  }

  .monthText {
      font-size: 30px ;
  }

  .buttonText {
    font-size: 14px ;
    fill: white;
    font-family: sans-serif;
    font-weight: 300 ;
  }

  .button {
    fill: red;
  }

path.line {
  fill: none;
  stroke: blue;
  stroke-width: 1.5px;
}

path.area {
  fill: #e7e7e7;
}

div.tooltip {
    background: white;
    text-align: left;
    padding-left: 5px;
    width: 300px;
    height: auto;
    font-size: 14px;
    border:solid gray;
    position: absolute;
    border-radius: 8px;
    border: 1px;
    pointer-events: none;
}

body{
  line-height: 1.5;
}

</style>
<body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/topojson/1.6.19/topojson.min.js"></script>
<script src="lib/d3.geo.projection.v0.min.js" charset="utf-8"></script>
<script>

var width = 1200*1.4,
    height = 600*1.4;

var scaleFactor = 1,
    centered,
    g;

var svg = d3.select("body")
    .append("svg")
    .attr("width", width)
    .attr("height", height)
    .attr("visibility","visible")
    .attr("id","mainsvg");


var div = d3.select("body").append("div")   
  .attr("class", "tooltip")               
  .style("opacity",0);

var path, geoData, color, earthquakeData, projection, earthquake;

//--------------------------------------
// Date format from CSV file: "4/5/2006"
var timeFormat = d3.time.format("%m/%d/%Y");

var startDate = new Date(1902,2),
    endDate   = new Date(2015,0) ;

var startNum = +startDate,
    endNum = +endDate ;

var dateInterp = d3.interpolateNumber(startNum, endNum) ;

var monthNames = [
        "January", "February", "March",
        "April", "May", "June", "July",
        "August", "September", "October",
        "November", "December"
    ];

var xLoc = 25,
    yLoc = 80,
    yDiff = 30 ;

var zoomX = 30,
    zoomY = 0.2*height,
    zoomWidth = 60,
    zoomHeight = 20,
    bdx = 8;

zoombutton = svg.append("rect")
            .attr("x",zoomX)
            .attr("y",zoomY)
            .attr("width",zoomWidth)
            .attr("height",zoomHeight)
            .attr("fill","#ffeda0")
            .attr("stroke-width",1.5)
            .attr("rx",8)
            .on("click",clickOut);

svg.append("text")
          .attr("x",zoomX+bdx)
          .attr("y",zoomY+zoomHeight/2)
          .attr("fill","black")
          .attr("text-anchor","start")
          .attr("font-size","10")
          .style("pointer-events",'none')
          .style("-webkit-user-select","none")
          .text("Zoom Out");


d3.json("world-220m_withoutAntarctica.json",function(topo){

    d3.csv("data.csv",function(error,data){

        geoData = topojson.feature(topo,topo.objects.countries) ;

        proj = d3.geo.eckert3();

        path = d3.geo.path().projection(proj);

      var center = d3.geo.centroid(geoData)
      var scale  = 250;
      var offset = [width/2, height/2];
      projection = d3.geo.eckert3()
        .scale(scale)
        .center(center)
        .translate(offset);

      // create the path
      path = d3.geo.path()
        .projection(projection);

      // using the path determine the bounds of the current map and use 
      // these to determine better values for the scale and translation

      var bounds  = path.bounds(geoData);
      var hscale  = scale*width  / (bounds[1][0] - bounds[0][0]);
      var vscale  = scale*height / (bounds[1][1] - bounds[0][1]);
      var scale   = (hscale < vscale) ? hscale : vscale;
      var offset  = [width - (bounds[0][0] + bounds[1][0])/2,
                        height - (bounds[0][1] + bounds[1][1])/2];

      // new projection
      projection = d3.geo.eckert3()
        .center(center)
        .scale(scale*0.95)
        .translate(offset);
      path = path.projection(projection);

      deathData = data.map(DEATH).sort(d3.ascending);
      minDeath = deathData[0];
      maxDeath = deathData[deathData.length-1];


      var radius = d3.scale.linear().domain([minDeath,maxDeath]).range([4,35]);

      // Order to make sure the smallest is on the top
      function order(a,b){
        return radius(a) - radius(b);
      }

     g = svg.append("g");

       g.append("g")
        .attr("class","region")
        .selectAll("path")
        .data(geoData.features)
        .enter()
        .append("path")
        .attr("d", path)
        .attr("fill", "white")
        .attr("id",function(d) {
                  return d.id;})
        .attr("stroke","black")
        .attr("stroke-width", 0.5)
        .style("opacity",1)
        .on("dblclick",clicked);


        g.selectAll("circle").data(data)
          .enter()
          .append("circle")
         .attr("cx", function(d) {
                return projection([+d.Latitude, +d.Longitude])[0];
            })
            .attr("cy", function(d) {
                return projection([+d.Latitude, +d.Longitude])[1];
            })
          .style("fill", "red")
          .style("fill-opacity", 0.5)
          .style("stroke", "red")
          .style("stroke-opacity", 0.5)
          .attr("r", function(d){ return radius(d.Death);})
          .sort(order)
          .on("mouseover",function(d){
          d3.select(this).transition().duration(300).style('opacity',1).attr("fill","#fee391");

          div.transition().duration(300)
          .style("opacity",1);

          div.html("<p>Year: " + d.Date + "<br>"+"Death: "+ d3.round(d.Death,0)+"<br>"+"Location: " + d.Location +"<br>"
                +"Magnitude: "+ d.Magnitude +"<br>"
                +"Comments: "+ d.Comments +"</p>")

          .style("left",(d3.event.pageX)+"px")
          .style("top",(d3.event.pageY+30) +"px");
          }).on("mouseout",function(){

               d3.select(this)
                  .transition()
                  .duration(300)
                  .style("opacity",1)
                  .attr("fill","red");

              div.transition()
                  .duration(300)
                  .style("opacity", 0);

          }).on("dblclick",clicked);
         
    });
});

function DEATH(d) {return +d.Death;};

// Click function for zooming in on double clicked area
function clicked(d) {
  var x, y;
  var mousePos = d3.mouse(this) ;

  if (d) {
    x = mousePos[0] ;
    y = mousePos[1] ;
    scaleFactor *= 2 ;
    scaleFactor = Math.min(scaleFactor,32) ;
  } else {
    x = width / 2;
    y = height / 2;
    scaleFactor = 1 ;
  }

  // This is for coloring the clicked states
  g.selectAll("path")
    .classed("active", centered && function(d) { return d === centered; });

  g.transition()
    .duration(750)
    .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")scale(" + scaleFactor + ")translate(" + -x + "," + -y + ")")
    .style("stroke-width", 1.25 / scaleFactor + "px");
};

// Zoom out to the original view
function clickOut() {
  var x, y;

  x = width / 2;
  y = height / 2;
  scaleFactor = 1;

  g.transition()
    .duration(750)
    .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")scale(" + scaleFactor + ")translate(" + -x + "," + -y + ")")
    .style("stroke-width", 1.5 / scaleFactor + "px");
}


</script>